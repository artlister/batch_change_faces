<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Artlist Labs ‚Äî Batch Photo Processor</title>
  <link rel="stylesheet" href="bulk-photo-processor.css" />
</head>
<body>
  <nav class="top-nav">
    <div class="nav-content">
      <div class="logo">
        <span class="logo-icon">‚ö°</span>
        <span class="logo-text">Artlist Labs</span>
      </div>
      <div class="nav-right">
        <span class="user-badge" id="statusBadge">Ready</span>
        <button class="btn btn-secondary" id="clearBtn" type="button">Clear</button>
      </div>
    </div>
  </nav>

  <main class="main-content">
    <section class="hero-section">
      <h1 class="hero-title">Batch Photo Processor ‚ú®</h1>
      <p class="hero-subtitle">
        Upload 1‚Äì50+ images, process them in parallel (FAL hookup later), compare before/after, then download a ZIP.
      </p>
    </section>

    <section class="panel">
      <div class="panel-header">
        <div>
          <h2 class="panel-title">Upload</h2>
          <p class="panel-subtitle">Drag & drop or pick files. Works with large batches.</p>
        </div>
        <div class="panel-actions">
          <button class="btn btn-secondary" id="demoBtn" type="button" title="Uses a placeholder processor for now">Run demo processing</button>
          <button class="btn btn-primary" id="processBtn" type="button" disabled>Process on FAL</button>
        </div>
      </div>

      <div class="dropzone" id="dropzone" role="button" tabindex="0" aria-label="Upload images">
        <div class="drop-inner">
          <div class="drop-icon">üñºÔ∏è</div>
          <div class="drop-text">
            <div class="drop-title">Drop images here</div>
            <div class="drop-subtitle">or click to select (JPG, PNG, WEBP)</div>
          </div>
          <input id="fileInput" class="file-input" type="file" accept="image/*" multiple />
        </div>
      </div>

      <div class="toolbar">
        <div class="stats">
          <div class="stat">
            <div class="stat-label">Selected</div>
            <div class="stat-value" id="selectedCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Processed</div>
            <div class="stat-value" id="processedCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Failed</div>
            <div class="stat-value" id="failedCount">0</div>
          </div>
        </div>

        <div class="toolbar-right">
          <label class="toggle">
            <input type="checkbox" id="onlyDoneToggle" />
            <span>Show processed only</span>
          </label>

          <button class="btn btn-secondary" id="downloadZipBtn" type="button" disabled>
            <span>‚¨áÔ∏è</span><span>Download ZIP</span>
          </button>
        </div>
      </div>

      <div class="note">
        <span class="note-dot">‚óè</span>
        <span>
          <strong>Hookup point:</strong> replace <code>processImage()</code> with your FAL call. The UI already supports parallel runs and ZIP export.
        </span>
      </div>
    </section>

    <section class="results">
      <div class="section-header">
        <h2 class="section-title">Results</h2>
        <div class="section-controls">
          <input class="search" id="searchInput" placeholder="Search filename‚Ä¶" />
          <select class="select" id="compareMode">
            <option value="slider" selected>Comparison: Slider</option>
            <option value="side-by-side">Comparison: Side-by-side</option>
          </select>
        </div>
      </div>

      <div id="grid" class="results-grid">
        <div class="empty-state" id="emptyState">No images yet ‚Äî upload some to get started.</div>
      </div>
    </section>
  </main>

  <!-- JSZip for ZIP download (client-side) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    // ======= State =======
    const state = {
      items: [], // { id, file, name, size, type, srcOriginal, srcProcessed, processedBlob, status, error }
      processing: false
    };

    const el = {
      statusBadge: document.getElementById('statusBadge'),
      clearBtn: document.getElementById('clearBtn'),
      demoBtn: document.getElementById('demoBtn'),
      processBtn: document.getElementById('processBtn'),
      downloadZipBtn: document.getElementById('downloadZipBtn'),
      dropzone: document.getElementById('dropzone'),
      fileInput: document.getElementById('fileInput'),
      grid: document.getElementById('grid'),
      emptyState: document.getElementById('emptyState'),
      selectedCount: document.getElementById('selectedCount'),
      processedCount: document.getElementById('processedCount'),
      failedCount: document.getElementById('failedCount'),
      onlyDoneToggle: document.getElementById('onlyDoneToggle'),
      compareMode: document.getElementById('compareMode'),
      searchInput: document.getElementById('searchInput'),
    };

    // ======= Helpers =======
    const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

    function setBadge(text, tone = 'neutral') {
      el.statusBadge.textContent = text;
      el.statusBadge.dataset.tone = tone;
    }

    function formatBytes(bytes) {
      const units = ['B','KB','MB','GB'];
      let v = bytes;
      let i = 0;
      while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
      return `${v.toFixed(v >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    }

    function updateStats() {
      const selected = state.items.length;
      const processed = state.items.filter(i => i.status === 'done').length;
      const failed = state.items.filter(i => i.status === 'error').length;

      el.selectedCount.textContent = selected;
      el.processedCount.textContent = processed;
      el.failedCount.textContent = failed;

      el.processBtn.disabled = selected === 0 || state.processing;
      el.demoBtn.disabled = selected === 0 || state.processing;
      el.downloadZipBtn.disabled = processed === 0 || state.processing;
      el.clearBtn.disabled = selected === 0 || state.processing;

      if (state.processing) setBadge('Processing‚Ä¶', 'warn');
      else if (processed > 0 && processed === selected) setBadge('All done', 'ok');
      else if (processed > 0) setBadge(`Done: ${processed}/${selected}`, 'ok');
      else setBadge('Ready', 'neutral');
    }

    function passesFilters(item) {
      if (el.onlyDoneToggle.checked && item.status !== 'done') return false;
      const q = el.searchInput.value.trim().toLowerCase();
      if (q && !item.name.toLowerCase().includes(q)) return false;
      return true;
    }

    function render() {
      el.grid.innerHTML = '';
      const mode = el.compareMode.value;

      const visible = state.items.filter(passesFilters);
      if (visible.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.textContent = state.items.length ? 'No matches. Try clearing filters.' : 'No images yet ‚Äî upload some to get started.';
        el.grid.appendChild(empty);
        updateStats();
        return;
      }

      for (const item of visible) {
        const card = document.createElement('article');
        card.className = 'result-card';

        const header = document.createElement('div');
        header.className = 'result-header';

        const meta = document.createElement('div');
        meta.className = 'result-meta';

        const name = document.createElement('div');
        name.className = 'result-name';
        name.textContent = item.name;

        const sub = document.createElement('div');
        sub.className = 'result-sub';
        sub.textContent = `${formatBytes(item.size)} ‚Ä¢ ${item.type || 'image'}`;

        meta.appendChild(name);
        meta.appendChild(sub);

        const pill = document.createElement('div');
        pill.className = `pill pill-${item.status}`;
        pill.textContent = item.status === 'idle' ? 'Queued' :
                          item.status === 'processing' ? 'Processing' :
                          item.status === 'done' ? 'Done' : 'Failed';

        header.appendChild(meta);
        header.appendChild(pill);

        const compare = document.createElement('div');
        compare.className = `compare compare-${mode}`;

        if (mode === 'side-by-side') {
          compare.appendChild(makeImgBlock('Before', item.srcOriginal));
          compare.appendChild(makeImgBlock('After', item.srcProcessed || item.srcOriginal, item.status !== 'done'));
        } else {
          compare.appendChild(makeSliderCompare(item));
        }

        const footer = document.createElement('div');
        footer.className = 'result-footer';

        const actions = document.createElement('div');
        actions.className = 'result-actions';

        const btnReprocess = document.createElement('button');
        btnReprocess.className = 'btn btn-secondary btn-sm';
        btnReprocess.type = 'button';
        btnReprocess.textContent = 'Reprocess';
        btnReprocess.disabled = state.processing;
        btnReprocess.onclick = () => processBatch([item.id], { demo: true });

        const btnDownload = document.createElement('button');
        btnDownload.className = 'btn btn-primary btn-sm';
        btnDownload.type = 'button';
        btnDownload.innerHTML = '<span>‚¨áÔ∏è</span><span>Download</span>';
        btnDownload.disabled = item.status !== 'done';
        btnDownload.onclick = () => downloadBlob(item.processedBlob, deriveOutName(item.name));

        actions.appendChild(btnReprocess);
        actions.appendChild(btnDownload);

        const error = document.createElement('div');
        error.className = 'result-error';
        error.textContent = item.status === 'error' ? (item.error || 'Failed to process') : '';
        if (!error.textContent) error.classList.add('hidden');

        footer.appendChild(actions);
        footer.appendChild(error);

        card.appendChild(header);
        card.appendChild(compare);
        card.appendChild(footer);
        el.grid.appendChild(card);
      }

      updateStats();
    }

    function makeImgBlock(label, src, dim = false) {
      const wrap = document.createElement('div');
      wrap.className = `img-block ${dim ? 'img-dim' : ''}`;

      const cap = document.createElement('div');
      cap.className = 'img-cap';
      cap.textContent = label;

      const img = document.createElement('img');
      img.alt = label;
      img.src = src;
      img.loading = 'lazy';

      wrap.appendChild(cap);
      wrap.appendChild(img);
      return wrap;
    }

    function makeSliderCompare(item) {
      const wrap = document.createElement('div');
      wrap.className = 'slider-wrap';

      const before = document.createElement('img');
      before.className = 'slider-img';
      before.alt = 'Before';
      before.src = item.srcOriginal;

      const afterWrap = document.createElement('div');
      afterWrap.className = 'slider-after';
      afterWrap.style.setProperty('--pct', '50%');

      const after = document.createElement('img');
      after.className = 'slider-img';
      after.alt = 'After';
      after.src = item.srcProcessed || item.srcOriginal;
      if (item.status !== 'done') after.classList.add('img-dim-filter');

      afterWrap.appendChild(after);

      const handle = document.createElement('div');
      handle.className = 'slider-handle';
      handle.innerHTML = '<span class="handle-dot"></span>';

      const range = document.createElement('input');
      range.type = 'range';
      range.min = 0;
      range.max = 100;
      range.value = 50;
      range.className = 'slider-range';
      range.setAttribute('aria-label', 'Comparison slider');

      const labelBar = document.createElement('div');
      labelBar.className = 'slider-labels';
      labelBar.innerHTML = '<span>Before</span><span>After</span>';

      function update(v) {
        afterWrap.style.setProperty('--pct', v + '%');
        handle.style.left = v + '%';
      }
      update(50);

      range.addEventListener('input', (e) => update(e.target.value));

      wrap.appendChild(before);
      wrap.appendChild(afterWrap);
      wrap.appendChild(labelBar);
      wrap.appendChild(handle);
      wrap.appendChild(range);

      return wrap;
    }

    function deriveOutName(name) {
      const dot = name.lastIndexOf('.');
      if (dot === -1) return name + '-processed.png';
      return name.slice(0, dot) + '-processed' + name.slice(dot);
    }

    function downloadBlob(blob, filename) {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }

    // ======= Upload handling =======
    function addFiles(fileList) {
      const files = Array.from(fileList).filter(f => f.type && f.type.startsWith('image/'));
      if (!files.length) return;

      for (const file of files) {
        const id = uid();
        const srcOriginal = URL.createObjectURL(file);

        state.items.push({
          id,
          file,
          name: file.name || `image-${id}.png`,
          size: file.size || 0,
          type: file.type || 'image/*',
          srcOriginal,
          srcProcessed: null,
          processedBlob: null,
          status: 'idle',
          error: null
        });
      }

      render();
    }

    el.dropzone.addEventListener('click', () => el.fileInput.click());
    el.fileInput.addEventListener('change', (e) => addFiles(e.target.files));

    el.dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      el.dropzone.classList.add('dropzone-hover');
    });
    el.dropzone.addEventListener('dragleave', () => el.dropzone.classList.remove('dropzone-hover'));
    el.dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      el.dropzone.classList.remove('dropzone-hover');
      addFiles(e.dataTransfer.files);
    });

    // keyboard accessibility
    el.dropzone.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); el.fileInput.click(); }
    });

    // ======= Processing (demo placeholder + parallel queue) =======
    async function processImageDemo(file) {
      // Placeholder: convert to canvas and apply a tiny "processing" effect (slight contrast + vignette)
      // Replace with FAL call later; return a Blob.
      const img = await blobToImage(file);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: false });

      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;

      ctx.drawImage(img, 0, 0);

      // simple contrast
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const d = imageData.data;
      const contrast = 1.08;
      const intercept = 128 * (1 - contrast);

      for (let i = 0; i < d.length; i += 4) {
        d[i] = clamp(d[i] * contrast + intercept);
        d[i + 1] = clamp(d[i + 1] * contrast + intercept);
        d[i + 2] = clamp(d[i + 2] * contrast + intercept);
      }
      ctx.putImageData(imageData, 0, 0);

      // vignette
      const grd = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) * 0.2,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.7
      );
      grd.addColorStop(0, 'rgba(0,0,0,0)');
      grd.addColorStop(1, 'rgba(0,0,0,0.18)');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      return await new Promise((resolve) => canvas.toBlob(resolve, 'image/png', 0.92));
    }

    function clamp(v) { return Math.max(0, Math.min(255, v)); }

    function blobToImage(fileOrBlob) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(fileOrBlob);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = reject;
        img.src = url;
      });
    }

    async function processImageFal(file) {
      // TODO: replace with real FAL call. Keep signature returning a Blob.
      // Example shape:
      // const res = await fetch('/fal/endpoint', { method:'POST', body: formData })
      // return await res.blob();
      throw new Error('FAL hookup not implemented yet');
    }

    async function processBatch(ids, { demo = false } = {}) {
      if (state.processing) return;
      state.processing = true;
      updateStats();

      // cap parallelism to keep UI responsive for huge batches (tweak as needed)
      const CONCURRENCY = 6;

      const queue = state.items.filter(i => ids.includes(i.id));
      if (!queue.length) { state.processing = false; updateStats(); return; }

      for (const item of queue) { item.status = 'processing'; item.error = null; }
      render();

      let idx = 0;
      let active = 0;

      return await new Promise((resolve) => {
        const next = () => {
          while (active < CONCURRENCY && idx < queue.length) {
            const item = queue[idx++];
            active++;

            (async () => {
              try {
                const outBlob = demo ? await processImageDemo(item.file) : await processImageFal(item.file);
                item.processedBlob = outBlob;
                item.srcProcessed = URL.createObjectURL(outBlob);
                item.status = 'done';
              } catch (err) {
                item.status = 'error';
                item.error = err?.message || String(err);
              } finally {
                active--;
                render();
                if (idx >= queue.length && active === 0) {
                  state.processing = false;
                  updateStats();
                  resolve();
                } else {
                  next();
                }
              }
            })();
          }
        };
        next();
      });
    }

    // ======= ZIP download =======
    async function downloadZip() {
      const done = state.items.filter(i => i.status === 'done' && i.processedBlob);
      if (!done.length) return;

      setBadge('Building ZIP‚Ä¶', 'warn');
      el.downloadZipBtn.disabled = true;

      const zip = new JSZip();
      const folder = zip.folder('processed');

      for (const item of done) {
        const name = deriveOutName(item.name);
        folder.file(name, item.processedBlob);
      }

      const blob = await zip.generateAsync({ type: 'blob' });
      downloadBlob(blob, `artlist-labs-processed-${new Date().toISOString().slice(0,10)}.zip`);

      updateStats();
    }

    // ======= Wiring =======
    el.demoBtn.addEventListener('click', () => processBatch(state.items.map(i => i.id), { demo: true }));
    el.processBtn.addEventListener('click', () => processBatch(state.items.map(i => i.id), { demo: false }));
    el.downloadZipBtn.addEventListener('click', downloadZip);

    el.clearBtn.addEventListener('click', () => {
      for (const item of state.items) {
        try { URL.revokeObjectURL(item.srcOriginal); } catch {}
        try { if (item.srcProcessed) URL.revokeObjectURL(item.srcProcessed); } catch {}
      }
      state.items = [];
      state.processing = false;
      el.fileInput.value = '';
      render();
    });

    el.onlyDoneToggle.addEventListener('change', render);
    el.compareMode.addEventListener('change', render);
    el.searchInput.addEventListener('input', () => {
      // simple debounce
      if (el.searchInput._t) clearTimeout(el.searchInput._t);
      el.searchInput._t = setTimeout(render, 80);
    });

    // initial render
    render();
  </script>
</body>
</html>
